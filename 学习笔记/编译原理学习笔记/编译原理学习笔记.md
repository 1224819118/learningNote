# 基本概念

我们平时所写的代码都并不是机器语言那么这是如何被电脑所解析的。

这样看这里面一定会有一个将目标高级语言转化为机械语言的过程，这个过程可能会被电脑交给一个专门完成这个工作的员工去做。这个员工可以叫他编译器。

想一想，我们平时想要看懂一个英文句子，首先我们一定是能够读懂句子里面的单词的，之后我们就会对这个句子按照一定语法进行分析将各个短语翻译出来，最后我们就会将这个句子的整个意思写出来。

这个过程可以看成高级语言翻译为一个目标语言的过程

词法分析->语法分析->语义分析

但是在实际过程中还要比上面这个过程稍微复杂一点

词法分析->语法分析->语义分析->中间代码生成器->代码优化器->目标代码生成器->机器语言的代码优化

这里面中间代码就像是我们之前所学的桥接模式中那个桥的概念。她负责将两个无关的语言结合起来，就像是一个中间的存储站一样一中间代码的形式存储语义，然后把这个中间代码交给下面的人让他们去将这个语义生成为机器语言并做一些优化比如是语法顺序之类的。





# 词法语法分析

当我们想要编译器能够自动的对一个高级语言进行解析编译的话我们一定会需要一个表来存储一些词法，就像是26个英文字母的字母表一样只有在了解了这些字母之后才能将由字母组成的语句翻译过来

## 字母表

**这个表就是字母表**

字母表可以看作是一个字符串的集合，{A,B,C,D}这就是一个长度为4的字母表

字母表之间也存在运算，比如字母表A={1,2} B={3,4}那么AB={1，3}，{1，4}，{2，3}，{2，4}

A的3次幂则={1,2} {1,2} {1,2}={111,112,121,122,211,212,221,222}这么看字母表A的3次幂就是长度为3的字符串的集合

字母表的正闭包：字母表上长度为正的字符串集合

字母表的克林闭包：在正闭包的基础上加一个空串

## 文法

G=(Vt,Vn,P,S)

Vt：终结符集合

Vn：非终结符集合

P：产生式集合

S：开始符号

![](images\文法表达式.PNG)

![](images\产生式简写.PNG)

## 文法的分类

**0型：无限制文法**

对于产生式没有限制仅仅要求产生式左部必须包含一个非终结符

**1型：上下文有关文法**

在0型文法的基础上进一步要求左边的符号的个数不能多于右边的个数（不包含空产生式）

**2型：上下文无关文法**

要求产生式左边必须是一个非终结符

**3型：正则文法**

右线性文法：在上面的基础上进一步要求右边部分表达式的右面包含一个非终结符要么就没有终结符

左线性文法：这个和上面那个正好相反

**总结：我们可以看出这四种文法从上到下是逐渐增大限制的过程，也就是说从上到下也是一个包含的过程，型的范围最大包含下面的所有文法，像这样1包含23，2包含3依次向下**

如果我们进一步分析正则文法就会发现她所构建的语言可以描述基本上所有的单词，而上下文无关文法则能够很好的描述句子的构造

## cfg的分析树（上下文无关文法）

![](images\CFG分析树.PNG)

![](images\CFG分析过程.PNG)

![](images\CFG短语概念.PNG)



## 正则文法

正则表达式(RE)

一种用来描述正则语言的方法

例：假如说一个字母表包含{a,b}，那么

L(a|b)={a,b}

L((a|b)(a|b))={a,b}{a,b}={ab,aa,ba,bb}

L(a*)={a}的克林闭包={空串,a,aa,aaa,....}

L(a|b)*={a,b}的克林闭包={空串,a,b,ab,ba,aab,abb.....}

## 有穷自动机

![](images/fa转换图.png)

fa**定义或接收的语言**

如果输入一个串可以使得自动机从初始状态到某个终止状态，那么就说这个串是自动机可以被该自动机接收

而所有的可以被接收的串的集合就是这个自动机的语言

**最长子串匹配原则**

当输入串的多个前缀和一个或者多个模式匹配时，总是选择最长前缀进行匹配

## 有穷自动关机的分类

- 确定有穷自动机    dfa
- 不确定有穷自动机

![](images/dfa分类图.png)





![](images/nfa转换图.png)



从上面的图可以看出，dfa和nfa之间的区别仅仅在于dfa在输入一个字母时只能到达一个状态，而nfa在输入一个字母时可能有两种不同的状态可以到达。

## **从正则表达式到有穷自动机**

由于直接从re到dfa是比较困难的，所以我们一般都是先将其转换为nfa之后再从nfa转换到dfa

![](images/re到nfa.png)



## **从nfa到dfa**

