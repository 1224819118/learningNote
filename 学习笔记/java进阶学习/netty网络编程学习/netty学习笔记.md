[TOC]



# 学习目标

1.掌握Java网络编程基本知识和原理

2.使用netty构建一个能推向产品线的Java网络服务器

3.熟悉netty核心源码以及深层原理

4.能够熟练诊断，分析并排查netty使用中的各种故障

# 一 初识netty （背景现状以及趋势）



# 二 netty 源码：从点（领域知识）的角度剖析

## 1.1 网络通信的三种io模式

### 1.1.1 什么是三种io模式

从我们生活中的三个场景来分析

我们去吃饭

- 排队打饭模式，我们排队等着打饭
- 点单被叫模式：我们先买好了饭付了钱，等饭好了叫我们我们再来拿
- 包厢模式：我们只负责花钱买饭等饭做好了服务员自己给我们端上来

我们可以将上面场景中的一些对象看为我们网络通信中的对象

- 饭店=服务器
- 饭菜=数据
- 饭菜做好了=数据准备完毕
- 取菜/上菜=数据读取

| 排队打饭模式 | bio(阻塞模式)   | jdk1.4之前                |
| ------------ | --------------- | ------------------------- |
| 点单被叫模式 | nio(非阻塞模式) | jdk1.4(2002年 Java.nio包) |
| 包厢模式     | aio(异步模式)   | jdk1.7 （2011年）         |



## 1.2 源码剖析：netty对io模式的支持

netty在前面的版本中已经将bio和aio设为弃用方法了，netty主推荐nio。

而在netty的底层实现中我们也可看到对于三种io模式netty提供的接口名称基本一致只是改了一下前缀，并且在底层netty通过反射+工厂的方法做到了我们在切换各种模式时基本不用改动什么代码就能做到切换。因为底层通过反射获取到我们相应的io模式然后其他的socket是通过returnserver socket的accept来获得完全不需要我们改动。

## 1.3 netty如何支持reactor模型

生活场景：饭店规模扩大了

- 还是自己做什么事都自己来
- 多雇几个人哪里缺人去哪里
- 多雇佣点前台迎宾，伙计做饭

对象类比：

- 饭店伙计=线程
- 迎宾工作=接入链接
- ​                 ----->1.一个人包揽所有工作=reactor单线程

- 点菜=请求---->2.多找几个伙计一起干=reactor多线程
- ​                 ----->3.进一步分工搞几个人专门迎宾=主从reactor多线程
- 做菜=处理业务
- 上菜=响应
- 送客=断开连接

Reactor三种版本

| BIO                   | NIO     | AIO      |
| --------------------- | ------- | -------- |
| Thread-Per-Connection | Reactor | Proactor |

**reactor就是一种开发模式它的核心流程：注册感兴趣的事件->扫描是否有感兴趣的事发送->事情发生后做出相应的处理**

| client/server | socketChannel/ServerSocketChannel | OP_ACCEPT | OP_CONNECT | OP_WRITE | OP_READ |
| ------------- | --------------------------------- | --------- | ---------- | -------- | ------- |
| client        | SocketChannel                     |           | Y          | Y        | Y       |
| server        | ServerSocketChannel               | Y         |            |          |         |
| server        | SocketChannel                     |           |            | Y        | Y       |

Thread-Per-Connection模式：

![](../java高级课程学习笔记\image\BIOReactor模式图.PNG)

 从上面可以看到这种模式每次处理请求就占用线程并且read/send都是阻塞操作。想要扩大规模就必须增加线程或者使用线程池。

 Reactor模式：

![](../java高级课程学习笔记\image\Reactor单线程模式图.PNG)

上面可以看到这个模式所有的操作都给一个线程去做，这肯定是不合理的，那么第一个想到的解决方法一定是增多了线程的数量

![](../java高级课程学习笔记\image\reactor多线程模式.PNG)

这个模式就是认为处理里面的一些工作十分耗时所有将他们单独拿出来放到一个工作线程池里去处理

但是这也不是我们当前主要使用的模式，就像之前的酒店一样，我们把前面和后台的工作分开交给不同的专员线程池去处理。

![](F:\opensource\学习积累\学习笔记\java进阶学习\java高级课程学习笔记\image\主从reactor多线程模式.PNG)

在netty中怎么使用Reactor模式

![](F:\opensource\学习积累\学习笔记\java进阶学习\java高级课程学习笔记\image\netty的Reactor使用方法.PNG)

Proactor模式：

## 1.4 源码剖析：netty对reactor模型的支持

## 1.5 TCP粘包,半包netty全搞定

**什么是粘包 半包**

首先我们要知道一个数据报它是由他的mtu（最大传输单元）的这个mtu限制了他一次最大传输的数据报中具体消息所能占有的大小这样就会出现两种情况：1.一次传输的数据比mtu小 2.一次传输的数据比mtu大

当一组数据他比mtu小时就会将另外一组数据一起放进来进行传输，这就是粘包。

而当一组数据大于mtu时就会进行按照分组交换的模式进行数据的分包，这样传过来的数据就不是完整的一组数据，这就是半包。

**为什么会出现这种现象**

在前面的计网中我们了解到tcp连接的建立是一次十分珍贵的建立他对于资源和时间的消耗远远大于udp所以在我们日常工作中不会在建立一次tcp连接只负责一次数据传输的。举个例子：一个页面中包含了多个图片数据，而我们在输入url之后会请求建立一次tcp连接这时将页面数据传输过来之后会发现还有多个图片要请求那么这个tcp连接不会断开而是并发的进行哪些图片的请求。这就是tcp会产生粘包，半包而udp并不会的原因。



**解决办法**

我们对于粘包的问题最大的困惑就是无法区分这一次传输过来的数据到第是一组还是多组的组合。这样我们只要找到一种方法将数据进行分界就可以了。

第一种方法是基本不会用的，就是将tcp连接由长连接改为短链接就是一次tcp连接只负责一次的数据传输这样在连接建立开始到结束过程中的信息就是我们要的一组传输信息。这个方法过于浪费效率还低不推荐。

第二钟就是我们进行对数据封装成帧（framing）这个方式有三种常见的实施方法如下：

| 固定长度     | 对消息报中的数据内容进行长度固定不够就多分一组少了就添加空行 | 不推荐应为它会产生资源的浪费毕竟有空行                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分隔符       | 在不同的消息组之间加入分隔符                                 | 推荐但是读取数据时要扫描内容而且会有转义的需求               |
| 提前固定长度 | 先解析大概要多长的数据在读取内容                             | 能够精准定位数据内容也不需要转义，理论上提前预支可能数据最大的长度也不难 |
| 其他方式     | 一些其他的方式比如json可以找成对的{}不成对就不是完整的一组   | 这个就根据实际场景多有不同                                   |

**netty对三种常见的方式的支持**

![](F:\opensource\学习积累\学习笔记\java进阶学习\java高级课程学习笔记\image\netty对封装成帧的支持.PNG)

## 1.6 源码解析：netty处理粘包半包问题



## 1.7 常用二次编解码方式

**什么是二次编解码**

上面提到了在数据传输的过程中我们将数据转化为字节流这个就是一次编码。而我们在应用层拿到这个字节流时是没办法直接当作对象来用的。所以还要将这个字节转化为具体的信息这个就是二次编码

**常见的二次编解码方式**

- Java序列化      不常用占用空间大而且只支持Java，做集成就很难
- Marshaling      jboss的
- XML                  占用比较大
- JSON                  占用比上一个小  *
- MessagePack    占用虽然很小但是性能差不过他基本支持所有语言  *
- Protobuf              性能好占用小可读性差   *
- 其他                    

## 1.8 netty对常用编解码



## 1.9 keepalive 与idle监测

为什么需要keepalive



怎么设计keepalive？



为什么还需要应用层的keepalive



idle监测是什么



如何在netty开启keepalive和idle监测

## 1.10 源码剖析：netty对于keepalive 与idle监测的支持

## 1.11 netty的锁

同步三要素：原子性，可见性，有序性

锁的分类：

​	乐观锁与悲观锁

​	公平锁和非公平锁

​	共享锁与独享锁

、

## 1.12 netty的内存使用

内存占用少

应用速度快

netty的技巧

​	减少对象本身的大小

​	能用基本类型不用包装类型，能定义为类变量的不定义为实例变量

​	预测分配大小减少Java中容器的自动扩容

​	零复制代替实际复制

**堆内内存堆外内存**

生活场景：

小区门前的烧烤店铺人满为患店内坐不下怎么办

解决思路：在店外摆点桌子

店内=jvm内部->堆（堆栈）+非堆（非堆栈）

店外=jvm外部->堆外（）

优点：空间更加广阔，减少了gc压力

缺点：创建比较慢，受操作系统管理

**内存池**

生活场景：烧烤店的菜单

1.用纸做菜带，一个客人一张纸

2.点菜平板，可以循环使用

如何实现内存池

1.开源实现 apache commons pool

2.netty轻量级实现 io.netty.util.Recycler



## 1.13 源码剖析：netty堆外内存和内存池的支持



# 三 netty源码：从线（请求处理）的角度剖析

## 3.1 源码剖析：启动服务

![](../java高级课程学习笔记\image\netty启动主线.PNG)

知识点：

启动服务的本质

- 创建一个多路复用器
- 初始化一个server socket channel
- 将server socket channel注册到多路复用器
- 将channel绑定端口
- 注册请求状态注册accept状态

- selector是在new NioEventLoopGroup()（创建一批NioEventLoop）时创建的
- 第一次注册并不是监听op_accept ，而是0；
- 最终监听accept是通过bind完成后的fireChannelActive来触发的
- NioEventLoop是通过注册操作的执行来完成启动的
- 类似于初始化器，可以将处理器设计为一次性的，用完就移除例如授权



## 3.2 源码剖析：创建链接

主线：

bossthread

- NioEventLoop中的多路复用器轮询训创建链接事件（op_accept）
- 创建socket channel
- 初始化socketchannel并从workgroup中选择一个NioEventLoop

workthread

- 将socket channel注册到NioEventLoop的selector
- 注册读事件（op_read）到selector上

知识点：

接受连接的本质

- 发现op_accept事件并进行处理
- 发现有了就调用server socket channel的accept方法
- 有了socket channel就将他进行注册
- 注册成功了在设置他的状态为op_read

# 四 netty实战入门：写一个玩具项目

## 4.1 编写网络应用程序的基本步骤

![](../java高级课程学习笔记\image\编写网络程序流程.PNG)



## 4.2 案例介绍以及数据结构



# 五 netty实战进阶 ：把玩具转化为产品项目



# 六 成长为netty的贡献者

