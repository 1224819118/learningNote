 # 多线程面试题

## 线程和进程的区别？

* 进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。 
*  进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。 
*  线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。 

##  创建线程有哪几种方式，如何实现？

①. 继承Thread类创建线程类

- 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
- 创建Thread子类的实例，即创建了线程对象。
- 调用线程对象的start()方法来启动该线程。

②. 通过Runnable接口创建线程类

- 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
- 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
- 调用线程对象的start()方法来启动该线程。

③. 通过Callable和Future创建线程

- 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
- 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
- 使用FutureTask对象作为Thread对象的target创建并启动新线程。
- 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

④. 通过线程池创建线程

* 调用Executors.newFixedThreadPool方法创建线程池。
* Runnable的匿名内部类创建线程。
* 结束要调用shutdown关闭线程池。

 ## runnable 和 callable 有什么区别

- Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
- Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。

## sleep和wait的区别

**基本区别**
sleep是Thread类的方法, wait是Object类中定义的方法
sleep()方法可以在任何地方使用
wait()方法只能在synchronized方法或synchronized块中使用（原因：wait方法会释放锁，只有在syn中才有所）

**本质区别**
Thread.sleep只会让出CPU ,不会导致锁行为的改变
Object.wait不仅让出CPU , 还会释放已经占有的同步资源锁

sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。
当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问， 可以通过notify，notifyAll方法来唤醒等待的线程 。

## notify()和 notifyAll()有什么区别

**锁池EntiyList**：当一个线程需要调用调用此方法时必须获得该对象的锁，而该对象的锁被其他线程占用，该线程就需要在一个地方等待锁释放，这个地方就是锁池。（准备抢锁的池子）
**等待池WaitSet**：调用了wait方法的线程会释放锁并进入等待池，在等待池的线程不会竞争锁。（休息的池子）

notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会

notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会。

## 线程的 run()和 start()有什么区别？/为什么不能直接调用 run() 方法？

每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。

start()方法来启动一个线程，这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码，真正实现了多线程运行。 此时start()方法启动的线程是处于就绪状态， 但并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， run方法运行结束， 此线程终止。然后CPU再调度其它线程。

**run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已**，直接调用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

## 线程的生命周期和状态

* 新建(New) :创建后尚未启动的线程的状态

* 可运行(Runnable):就绪和运行两种状态统称为运行中

* 阻塞(Blocked):等待获取排它锁 

* 无限期等待(Waiting): 阻塞和等待的区别在于，阻塞是被动的，而等待是主动的，不会被分配CPU执行时间,需要显式被唤醒

| 进入方法                                   | 退出方法                             |
| ------------------------------------------ | ------------------------------------ |
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                 |
| LockSupport.park() 方法                    | LockSupport.unpark(Thread)           |

* 限期等待(Timed Waiting):在一定时间后会由系统自动唤醒

| 进入方法                                 | 退出方法                                        |
| ---------------------------------------- | ----------------------------------------------- |
| Thread.sleep() 方法                      | 时间结束                                        |
| 设置了 Timeout 参数的 Object.wait() 方法 | 时间结束 / Object.notify() / Object.notifyAll() |
| 设置了 Timeout 参数的 Thread.join() 方法 | 时间结束 / 被调用的线程执行完毕                 |
| LockSupport.parkNanos() 方法             | LockSupport.unpark(Thread)                      |
| LockSupport.parkUntil() 方法             | LockSupport.unpark(Thread)                      |

调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 

* 结束(Terminated):已终止线程的状态,线程已经结束执行 

## 线程的各种状态的切换（重要）
<div align="center"> <img src="https://github.com/lvminghui/Java-Notes/blob/master/docs/imgs/线程状态切换.png"/> </div><br>


1. 得到一个线程类，new出一个实例线程就进入new状态（新建状态）。
2. 调用start方法就进入Runnable（可运行状态）
3. 如果此状态被操作系统选中并获得时间片就进入Running状态
4. 如果Running状态的线程的时间片用完或者调用yield方法就**可能**回到Runnable状态
5. 处于Running状态的线程如果在等待用户输入或者调用了sleep方法就会进入Blocked状态（阻塞状态），会让出CPU，但如果有锁不会释放锁。
6. 处于Running状态的线程如果在调用有锁（synchronized）的对象就会进入锁池，在锁池等待的线程如果拿到锁就会回到Runnable状态。
7. 处于Running状态的线程如果调用了wait就会进入等待池，在等待池的线程如果等待时间到或者调用notify方法就会进入锁池。
8. 处于Running状态的线程方法执行完毕或者异常退出就会进入死亡状态。

## 什么是上下文切换?

多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式（程序计数器）。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。

上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 

## 创建线程池有哪几种方式？

①. newFixedThreadPool(int nThreads)
创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

②. newCachedThreadPool()
创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。

③. newSingleThreadExecutor()
这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。

④. newScheduledThreadPool(int corePoolSize)（推荐）
创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

## 线程池都有哪些状态

RUNNING :能接受新提交的任务,并且也能处理阻塞队列中的任务
SHUTDOWN :不再接受新提交的任务,但可以处理存量任务
STOP :不再接受新提交的任务,也不处理存量任务
TIDYING :所有的任务都已终止
TERMINATED : 结束方法terminated()执行完后进入该状态 

## 执行execute()方法和submit()方法的区别是什么呢？

1. **`execute()`方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；**
2. **`submit()`方法用于提交需要返回值的任务。线程池会返回一个 `Future` 类型的对象，通过这个 `Future` 对象可以判断任务是否执行成功**，并且可以通过 `Future` 的 `get()`方法来获取返回值，`get()`方法会阻塞当前线程直到任务完成，而使用 `get（long timeout，TimeUnit unit）`方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。

## 在 java 程序中怎么保证多线程的运行安全？

线程安全在三个方面体现：

原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；

可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；

有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。

synchronized锁的不是代码是对象。
